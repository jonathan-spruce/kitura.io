<html lang="en">

<head>
  <title>Learn - Kitura Create</title>
  <link rel="icon" type="image/png" href="../../assets/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../../assets/favicon-16x16.png" sizes="16x16" />
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="../../scripts/prism.js"></script>
  <link rel="stylesheet" href="../../css/reset.css">
  <link rel="stylesheet" href="../../css/main.css">
  <link rel="stylesheet" href="../../css/guides.css">
  <link rel="stylesheet" media="screen and (max-width: 900px)" href="../../css/mobile_guides.css">
</head>

<header>
  <div class="header-container">
    <div class="header-main">
      <a class="home-link" href="../../../">
        <img class="header-logo" src="../../assets/kitura-logo.png" alt="Kitura logo">
        <h1 class="header-title">KITURA</h1>
      </a>
    </div>
    <nav class="header-nav">
      <a class="header-link active-nav" href="../../../learn">LEARN</a>
      <a class="header-link" href="../../../packages">PACKAGES</a>
      <a class="header-link" href="../../../events">EVENTS</a>
      <a class="header-link" href="../../../help">HELP</a>
    </nav>
  </div>
</header>
<body>
  <section class="guide-content">
    <div class="title-block">
        <img width="480px" src="../../assets/Kitura.svg" alt="Kitura Logo">
      <h1>USING KITURA CREATE</h1>
    </div>
    <h2>OVERVIEW</h2>
    <p>The kitura create command is a command-line tool that provides a guided question-and-answer way to create Kitura Swift applications.</p>
    <p>The generator supports two different ways to generate an application: scaffolding a starter and generating a CRUD application.</p>
    <h3>Scaffolding a starter</h2>
    <p>A scaffolded starter is an application containing boilerplate code but little or no application logic. You can use this as a base for your application by modifying the generated files with your application logic.</p>
    <p>You can select from a number of different options presented by the generator to define extra content to be included in the resulting application. For example, these include things like adding the boilerplate for serving static files and creating connections to databases.</p>
    <h3>Generating a CRUD application</h2>
    <p>A CRUD (Create-Read-Update-Delete) application is one where you provide a description of a data model and the generator creates application code for a REST webservice that will provide endpoints to perform create, read, update and delete operations for data matching that data model. In the current version of the generator, most of the generated CRUD application is not open for modification or extension—expect this to change in a future version to allow for more flexibility.</p>
    <h2>Installation</h2>
    <h3>macOS</h3>
    <p>Follow the <a href="../gettingstarted.html">Getting Started</a>.</p>
    <h3>Ubuntu Linux</h3>
    <p>Prerequisities</p>
    <ul>
      <li>Install Node.js. If you haven’t already installed Node.js, download the pre-built installer for your platform and run it.</li>
      <li>Install Swift 4.0.x, so that the tool can compile the generated Kitura/Swift application. For installation instructions, see Kitura: Setting up.</li>
    </ul>
    <p>Complete the following steps to install Swift Server Generator</p>
    <ul>
      <li>1. Open a Terminal window.</li>
      <li>2. You will need the Yeoman command line utility yo installed in your global Node.js module directory:</li>
    </ul>
    <pre><code class="language-swift">npm install -g yo</code></pre>
    <ul>
      <li>3. To install Swift Server Generator, run the following command:</li>
    </ul>
    <pre><code class="language-swift">npm install -g generator-swiftserver</code></pre>

    <blockquote class="info">
      <p>Swift Server Generator is supported only on the following operating systems:</p>
      <ul>
        <li>> Ubuntu Linux 14.04 LTS</li>
        <li>> Ubuntu Linux 16.04 LTS</li>
      </ul>
    </blockquote>

    <h2>Getting Started</h2>
    <p>First, run the Kitura application generation (see Command line tools):</p>
    <pre><code class="language-swift">kitura create</code></pre>
    <p>Enter swiftserver-getting-started as the application name.</p>
    <pre><code class="language-swift">What's the name of your application? swiftserver-getting-started</code></pre>
    <blockquote class="tip">
      <p>Tip: You can use a different name for the application, but if you do, be sure to substitute your name for swiftserver-getting-started throughout the rest of this tutorial.</p>
    </blockquote>
    <p>Press Enter to accept the default directory for the project (the same as the application name).</p>
    <pre><code class="language-swift">Enter the name of the directory to contain the project: (swiftserver-getting-started)</code></pre>
    <p>Select Scaffold a starter at the type of project prompt and press Enter.</p>
    <pre><code>Select type of project: (Use arrow keys)
❯ Scaffold a starter
  Generate a CRUD application</code></pre>
    <p>Select Web at the application pattern prompt (this determines the default set of capabilities) and press Enter</p>
    <pre><code>Select capability presets for application pattern: (Use arrow keys)
  Basic
❯ Web
  Backend for frontend</code></pre>
    <p>Press Enter to accept the default capabilities for the Web application pattern.</p>
    <pre><code class="language-swift">Select capabilities: (Press {space} to select, {a} to toggle all, {i} to inverse selection)
❯ ◉ Static web file serving
  ◯ Swagger UI
  ◉ Embedded metrics dashboard
  ◉ Docker files</code></pre>
    <p>Press Enter to accept the default of not generating code from a swagger specification in the scaffolding.</p>
    <pre><code class="language-swift">Select endpoints to generate: (Press <space> to select, {a} to toggle all, <i> to inverse selection)
❯ ◯ Swagger file serving endpoint
  ◯ Endpoints from a swagger file</code></pre>
    <p>Press Enter to accept the default of not generating a Swift server SDK from a swagger file in the scaffolding.</p>
    <pre><code class="language-swift">Would you like to generate a Swift server SDK from a Swagger file? (y/N)</code></pre>
    <p>Press Enter to accept the default of not including any boilerplate for services in the scaffolding.</p>
    <pre><code class="language-swift">Generate boilerplate for services: (Press <space> to select, {a} to toggle all, <i> to inverse selection)
❯ ◯ Cloudant / CouchDB
  ◯ Redis
  ◯ MongoDB
  ◯ PostgreSQL
  ◯ Object Storage
  ◯ AppID
  ◯ Auto-scaling</code></pre>
    <p>The generator will display messages as it scaffolds and builds the application including:</p>
    <ul>
      <li>1. Initializing the project folder structure.</li>
      <li>2. Creating and compiling default Swift files.</li>
      <li>3. Downloading and installing dependent Swift modules (as if you had manually run swift build).</li>
    </ul>
    <p>Now you should have a generated application directory similar to this:</p>
    <pre><code class="language-swift">swiftserver-getting-started/
├── public/
├── Sources/
│   ├── Application
│   │   ├── Application.swift
│   │   ├── Metrics.swift
│   │   └── Routes/
│   │       └── HealthRoutes.swift
│   └── swiftserver-getting-started
│       └── main.swift
├── Package.swift
├── README.md
├── config.json
└── ...</code></pre>
    <blockquote class="info">
      <p>For a description of the generated files, take a look at the structure of a generated project in the Project layout reference.</p>
    </blockquote>
    <p>Change to the application directory:</p>
    <pre><code class="language-swift">cd swiftserver-getting-started</code></pre>
    <p>Start the application:</p>
    <pre><code class="language-swift">.build/debug/swiftserver-getting-started</code></pre>
    <p>Confirm the application is running locally by opening the URL http://localhost:8080 in your browser. You’ll see something like this:</p>
    <pre><code class="language-swift">Welcome to Kitura
Your Kitura based server is up and running!</code></pre>
    <p>Congratulations, you now have a simple Kitura web application ready for extension with your own application logic. Now you can:</p>
    <ul>
      <li>1. Review and modify the generated code.</li>
      <li>2. Create web content in the public directory.</li>
      <li>3. View the embedded metrics dashboard on http://localhost:8080/swiftmetrics-dash.</li>
    </ul>
    <h2>CORE CONCEPTS</h2>
    <p>The kitura create command creates a Kitura Swift application based on the project type, capabilities and services you select. To do this, use the command-line tools provided by installing the generator.</p>
    <h3>Project type</h3>
    <p>The project type defines whether the generated application is a scaffold or CRUD application.</p>
    <h4>Scaffold</h4>
    <p>This project type is for creating a starter application where you define all of the application logic yourself. The generator will create the directory structure and boilerplate code based on the capabilities and services you select.</p>
    <blockquote class="info">
      <p>You may modify any of the generated code and will not be expected to run the generator again on the generated project.</p>
    </blockquote>
    <h4>CRUD</h4>
    <p>This project type is for creating a CRUD (Create-Read-Update-Delete) application where you provide a description of a data model and the generator creates application code for a REST webservice that will provide endpoints to perform create, read, update and delete operations for data matching that data model.</p>
    <p>The data model is specified by using the model generator on the generated project to create each piece of the data model, or by using the property generator on the generated project to modify existing pieces.</p>
    <p>Throughout the documentation we will use the following terminology:</p>
    <ul>
      <li>“data model” — the data model as a whole (eg: the bookstore data model)</li>
      <li>“model” — a piece of the data model (eg: the book model)</li>
      <li>“property” — a property of a model (eg: the title of a book)</li>
      <li>“entity” — a particular set of data matching a model (eg: a book with title “War and Peace”)</li>
    </ul>
    <p>Each time the data model is modified, parts of the project are regenerated to match the updated definition and the application will be rebuilt with swift build.</p>
    <p>When you define a model it automatically comes with a predefined REST API with a full set of create, read, update, and delete operations. This REST API is described in more detail in Exposing Swift Server Generator models over REST.</p>
    <p>You can create models by using the model generator, which creates a Model definition JSON file that defines your model. By convention, this file is located in the project’s models directory; for example, models/bookstore.json.</p>
    <p>After a model and its properties have been defined, an OpenAPI (Swagger 2.0) specification is also generated that describes and documents the REST APIs. By convention, this is located in the project’s definitions directory; for example, definitions/bookstore.yaml.</p>
    <blockquote class="warning">
      <p>You should not modify the code in the Sources/Generated directory, or the OpenAPI Swagger definition file in the definitions directory as any modifications will be lost when these files are regenerated.</p>
    </blockquote>
    <h3>Capabilities</h3>
    <p>Capabilities define chunks of functionality that will be implemented by the generated application. The application generator will ask you to select the capabilities you would like included.</p>
    <p>For the scaffold project type, you can select from the following list:</p>
    <ul>
      <li>Static web file serving</li>
      <li>Swagger UI</li>
      <li>Embedded metrics dashboard</li>
      <li>Docker files</li>
    </ul>
    <p>For the CRUD project type, you can select from the following list:</p>
    <ul>
      <li>Embedded metrics dashboard</li>
      <li>Docker files</li>
    </ul>
    <p>The list allows for toggling of any combination of the available capabilities which will start with a default set selected.</p>
    <p>The default set will depend on the project type:</p>
    <ul>
      <li>CRUD project type: all 3 available capabilities are selected by default</li>
      <li>Scaffold project type: defaults depend on application pattern</li>
    </ul>
    <h3>Web capability</h3>
    <p>This capability will include a public directory in the root of the project. The contents of this directory will be served as static content using the built-in Kitura StaticFileServer module.</p>
    <p>This content is hosted on /. For example, if you want to view public/myfile.html and the application is hosted at https://localhost:8080, go to https://localhost:8080/myfile.html.</p>
    <p>This capability is only available for scaffold projects.</p>
    <h3>Metrics dashboard capability</h3>
    <p>This capability uses the SwiftMetrics package to gather application and system metrics.</p>
    <p>These metrics can be viewed in an embedded dashboard on /swiftmetrics-dash. The dashboard displays various system and application metrics, including CPU, memory usage, HTTP response metrics and more.</p>
    <h3>Docker capability</h3>
    <p>This capability includes the following files for Docker and Kubernetes support:</p>
    <ul>
      <li>.dockerignore</li>
      <li>Dockerfile</li>
      <li>Dockerfile-tools</li>
      <li>chart</li>
    </ul>
    <p>The .dockerignore file contains the files/directories that should not be included in the built docker image. By default this file contains the Dockerfile and Dockerfile-tools. It can be modified as required.</p>
    <p>The Dockerfile defines the specification of the default docker image for running the application. This image can be used to run the application.</p>
    <p>The Dockerfile-tools is a docker specification file similar to the Dockerfile, except it includes the tools required for compiling the application. This image can be used to compile the application.</p>
    <p>The chart folder contains pre-configured Kubernetes resources for this project. It allows the use of Helm to streamline the deployment of a docker image to the cloud.</p>
    <p>To build the two docker images, run the following commands from the root directory of the project:</p>
    <pre><code class="language-swift">docker build -t myapp-run .
docker build -t myapp-build -f Dockerfile-tools .</code></pre>
    <p>You may customize the names of these images by specifying a different value after the -t option.</p>
    <p>To compile the application using the tools docker image, run:</p>
    <pre><code class="language-swift">docker run -v $PWD:/root/project -w /root/project myapp-build /swift-utils/tools-utils.sh build release</code></pre>
    <p>To run the application:</p>
    <pre><code class="language-swift">docker run -it -p 8080:8080 -v $PWD:/root/project -w /root/project myapp-run sh -c .build-ubuntu/release/{app_executable}</code></pre>
    <h4>Server SDK generation</h4>
    <p>This is the capability to generate a server SDK library from a swagger specification document, which can be used to allow the generated server application to call APIs on an external service. Providing the swagger document for the external service allows client-side Swift API stubs to be generated into the Routes directory.</p>
    <h3>Endpoints</h3>
    <h4>Swagger fileserving endpoint capability</h4>
    <p>This capability adds an endpoint to the application to provide file serving of an OpenAPI Swagger definition file for this application. This assumes that a pre-prepared Swagger document has been written and will be placed at definitions/{app_name}.yaml.</p>
    <p>The endpoint is hosted on /swagger/api. For example, if the application is hosted at https://localhost:8080, go to https://localhost:8080/swagger/api.</p>
    <p>This capability is only optional for scaffold projects and is always enabled in CRUD projects.</p>
    <p>If the SwaggerUI capability and Swagger endpoint capability are enabled then specification of this interface is made available through an embedded Swagger UI hosted on /explorer. For example, if the application is hosted at https://localhost:8080, go to https://localhost:8080/explorer. The Swagger UI will document the paths and http methods that are supported by the application.</p>
    <h4>Endpoints from swaggerfile capability</h4>
    <p>This capability will generate example or custom API endpoint code from an OpenAPI (swagger) document. If selected, then the fileserving endpoint capability is automatically enabled.</p>
    <h5>Example endpoints capability</h5>
    <p>This capability includes an OpenAPI Swagger definition and routes for a Product example resource. The OpenAPI Swagger definition is located at definitions/{app_name}.yaml.</p>
    <h5>Endpoints from swagger file</h5>
    <p>The user can choose to generate endpoints by specifing the path or URL to a swagger specification document.</p>
    <p>This capability is only available for scaffold projects.</p>
    <h4>SwaggerUI capability</h4>
    <p>This capability uses an embedded Swagger explorer web page to load and display the OpenAPI Swagger definition in the user friendly explorer web page. Through the explorer page, the user can view and exercise the APIs documented within the Swagger document.</p>
    <h3>Services</h3>
    <p>The services offered by the generator will depend on the project type and capabilities you have selected.</p>
    <p>For CRUD project type no services are available except those that are implied by the CRUD store prompt.</p>
    <h4>IBM Cloud services</h4>
    <p>These services are hosted on IBM Cloud and the application can connect to them either locally or when deployed to IBM Cloud.</p>
    <p>When IBM Cloud services are selected, a set of deployment configuration files to support deploying your application to IBM Cloud are created:</p>
    <ul>
      <li>manifest.yml</li>
      <li>.bluemix/toolchain.yml</li>
      <li>.bluemix/pipeline.yml</li>
    </ul>
    <p>The manifest.yml defines options which are passed to the Cloud Foundry cf push command during application deployment.</p>
    <p>IBM Cloud DevOps service provides toolchains as a set of tool integrations that support development, deployment, and operations tasks inside IBM Cloud. The “Create Toolchain” button in the README.md creates a DevOps toolchain and acts as a single-click deploy to IBM Cloud including provisioning all required services.</p>
    <blockquote class="warning">
      <p>You need to publish your project to a public github.com repository to use the “Create toolchain” button.</p>
    </blockquote>
    <h5>Cloudant IBM Cloud service</h5>
    <p>This service uses the Kitura-CouchDB package, which allows Kitura applications to interact with a Cloudant or CouchDB database.</p>
    <p>CouchDB speaks JSON natively and supports binary for all your data storage needs.</p>
    <p>Boilerplate code for creating a client object for the Kitura-CouchDB API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the Kitura-CouchDB client.</p>
    <h5>Redis IBM Cloud service</h5>
    <p>This service uses the Kitura-redis library, which allows Kitura applications to interact with a Redis database.</p>
    <p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports a cracking array of data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries.</p>
    <p>Boilerplate code for creating a client object for the Kitura-redis API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the Kitura-redis client.</p>
    <h5>PostgreSQL IBM Cloud service</h5>
    <p>This service uses the Swift-Kuery-ORM which allows Kitura applications to interact with a PostgreSQL database.</p>
    <p>Boilerplate code for creating a client object for the Swift-Kuery-ORM is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the PostgreSQL client.</p>
    <h5>Object Storage IBM Cloud service</h5>
    <p>This service uses the Object Storage package to connect to the IBM Cloud Object Storage service.</p>
    <p>Object Storage provides an unstructured cloud data store, which allows the application to store and access unstructured data content.</p>
    <p>Boilerplate code for creating a client object for the Object Storage API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the Object Storage client.</p>
    <h5>AppID IBM Cloud service</h5>
    <p>This service uses App ID package to connect to the IBM Cloud App ID service.</p>
    <p>App ID provides authentication to secure your web applications and back-end systems. In addition App ID supports authentication using social identity providers so that users can login with their existing user accounts, such as Facebook and Google.</p>
    <p>Boilerplate code for creating a client object for the App ID API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module. Extra routes and logic need to be added to make this a authentication boilerplate work. A working example can be found in the App ID README.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the App ID client.</p>
    <h5>Auto-scaling IBM Cloud service</h5>
    <p>This service uses the SwiftMetrics package for connecting to the IBM Cloud Auto-scaling service. You can use this to automatically manage your application capacity when deployed to IBM Cloud. You will need to define the Auto-Scaling policy (https://console.ng.bluemix.net/docs/services/Auto-Scaling/index.html) to define the rules used to scale the application.</p>
    <p>The connection details for this client are loaded by the configuration boilerplate code and are passed to the SwiftMetrics auto-scaling client.</p>
    <h5>Watson Conversation IBM Cloud Service</h5>
    <p>This service uses the Watson Swift SDK package, which allows Kitura applications to build Watson-powered applications, specifically in this case the IBM Watson Conversation service.</p>
    <p>With the IBM Watson Conversation service you can create an AI assistant that combines machine learning, natural language understanding, and integrated dialog scripting tools to build outstanding projects, such as a chat room with an integrated Watson chat bot.</p>
    <p>Boilerplate code for creating a client object for the Watson Conversation API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration code and are passed to the Watson Conversation client in the boilerplate code.</p>
    <p>More information about the Watson Conversation can be found in the README.</p>
    <h5>Alert Notification IBM Cloud Service</h5>
    <p>This service uses the Alert Notification Service SDK package, which allows Swift developers to utilize the Alert Notifications service in their applications, allowing for the proactive remediation of issues for applications running on IBM Cloud. Alerts and messages can be created, received and deleted through the use of this SDK.</p>
    <p>This SDK is for the consumption/usage of the Alert Notification service and not for administration of the service. Adding users, groups, notification policies, etc. should be done through the IBM Cloud dashboard.</p>
    <p>Boilerplate code for creating a client object for the Alert Notification API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration code and are passed to the Alert Notification client in the boilerplate code.</p>
    <p>A quick start guide to the Alert Notification Service on IBM Cloud can be found here.</p>
    <h5>A quick start guide to the Alert Notification Service on IBM Cloud can be found here.</h5>
    <p>This service uses the Push notifications package, which is a Swift server-side SDK for sending push notifications via the IBM Cloud Push Notifications service.</p>
    <p>Boilerplate code for creating a client object for the Push Notifications API is included inside Sources/Application/Application.swift as an internal variable available for use anywhere in the Application module.</p>
    <p>The connection details for this client are loaded by the configuration code and are passed to the Push Notifications client in the boilerplate code.</p>
    <p>More information about the Push Notifications Service can be found in the README.</p>
  </section>
  <section class="slack-help">
    <a href="http://slack.kitura.io/">
      <img width="80px" src="../../assets/slack-icon.png" alt="Slack icon">
      <h2>NEED HELP?</h2>
      <h2>MESSAGE US ON SLACK.</h2>
    </a>
  </section>
</body>
<footer>

  <nav class="footer-nav">
    <a class="footer-link" href="https://forums.swift.org/c/related-projects/kitura">FORUMS</a>
    <a class="footer-link" href="https://github.com/IBM-Swift/Kitura"><img class="footer-logo" src="../../assets/Kitura-White.svg" alt="Kitura logo"></a>
    <a class="footer-link" href="https://developer.ibm.com/swift/blogs/">BLOGS</a>
  </nav>
</footer>
</html>
